from sympy.external import import_module
import os

pycp = import_module('pycparser')

"""
This module contains all the necessary Classes and Function used to Parse
C code into SymPy expression
The module serves as a backend for SymPyExpression to parse C code
It is also dependent on pycparser's AST and SymPy's Codegen AST.
The module only supports the features currently supported by the pycparser and
codegen AST which will be updated as the development of codegen AST and this
module progresses.
You might find unexpected bugs and exceptions while using the module, feel free
to report them to the SymPy Issue Tracker

Features Supported
==================

- Variable Declarations (integers and reals)

Notes
=====

The module is dependent on an external dependency which needs to be installed
to use the features of this module.

PyCParser: The C parser which is used to extract an AST from the provided
C source code.

Reference
=========

.. [1] https://github.com/sympy/sympy/issues
.. [2] https://github.com/eliben/pycparser

"""

if pycp:
	from sympy.codegen.ast import (Variable, IntBaseType, FloatBaseType, String,
        Integer, Float)
	
	parser = pycp.CParser()

	class CCodeConverter:
		""" Main class which handles CPyParser AST

		To carry out conversion from C source code to
		SymPy Expressions
		"""
		def __init__(self):
			"""Constructor of CCodeConverter"""
			self.source_string = None
			self.source_file = None
			self.expr_nodes = []

		def parse(self, ast):
			"""Generalized method to parse given pycparser AST

			This function takes pycparser generated AST in
			the parameter, traverse the nodes and gives out
			SymPy Expressions.

			Parameters
			==========

			ast: FileAST
				AST object as generated by the PyCParser

			Returns
			=======

			expr_nodes: list
				A list of SymPy Codegen AST nodes

			"""
			for child in ast.children():
				if isinstance(child[1], pycp.c_ast.Decl):
					self.expr_nodes.append(self.transform_decl(child[1]))
			return self.expr_nodes

		def parse_str(self, c_str):
			"""Method to generate AST from C string

			This function takes C source code as a normal python
			string, generates PyCParser AST, calls main parse
			method and gives out SymPy Expressions.

			Parameters
			==========

			c_str: str
				C source code represented as a string

			Returns
			=======

			expr_nodes: list
				A list of SymPy Codegen AST nodes

			"""
			self.source_string = c_str
			try:
				ast = parser.parse(c_str)
				return self.parse(ast)
			except pycp.c_parser.ParseError as pe:
				print("Parse error"+str(pe))

		def parse_file(self, c_file):
			"""Method to generate AST from a C file
			
			This function takes a file containing C source code,
			generates PyCParser AST, calls main parse
			method and gives out SymPy Expressions.

			Parameters
			==========

			c_file: str
				Path to the C file represented as a string

			Returns
			=======

			expr_nodes: list
				A list of SymPy Codegen AST nodes

			"""
			self.source_file = c_file
			try:
				ast = parser.parse_file(c_file)
				return self.parse(ast)
			except pycp.c_parser.ParseError as pe:
				print("Parse error"+str(pe))

		def transform_decl(self, node):
			"""Method to handle variable declaration in C

			To generate SymPy Codegen nodes for variable declarations
			for the corresponding nodes of PyCParser AST

			Parameters
			==========

			node: Decl
				a Decl object of PyCParser AST containing
				variable declaration

			Returns
			=======

			node:  Variable
				a Variable object, containing given value, name
				and type


			Raises
			======

			NotImplementedError: if called for data types not currently
			implemented

			Notes
			=====

			This function supports declaration of integer and floating
			point type variables only

			"""
			decl_type = node.type.type.names[0]
			value = None
			# when variable is not initialized
			if node.init == None:
				if decl_type == 'int':
					type = IntBaseType(String('integer'))
					value = Integer(0)
				elif decl_type == 'float':
					type = FloatBaseType(String('real'))
					value = Float(0.0)
				else:
					raise NotImplementedError("Only integer and float \
						declarations are accepted!")
			else:
				init_type = node.init.type
				# when character is assigned to integer variable
				if decl_type == 'int' and init_type == 'char':
					type = IntBaseType(String('integer'))
					value = Integer(self.transform_constant(node))
				if decl_type == 'int':
					type = IntBaseType(String('integer'))
					value = Integer(self.transform_constant(node))
				elif decl_type == 'float':
					type = FloatBaseType(String('real'))
					value = Float(self.transform_constant(node))
				else:
					raise NotImplementedError("Only integer and float \
						declarations are accepted!")
			return Variable(
				node.name
			).as_Declaration(
				type = type,
				value = value
			)

		def transform_constant(self, node):
			if(node.init.type == 'int'):
				return int(node.init.value)
			if(node.init.type == 'float'):
				return float(node.init.value)
			if(node.init.type == 'char'):
				return ord(node.init.value[1])
else:
	# when clang is not installed
	class CCodeConverter:
		def __init__(self, *args, **kwargs):
			raise ImportError("Module not Installed")

def parse_c(c_source):
	"""Function for converting a C source code

    The function reads the source code present in the given file and parses it
    to give out SymPy Expressions

    Returns
    =======

    src : list
        List of Python expression strings

    """
	converter = CCodeConverter()
	if os.path.exists(c_source):
		src = converter.parse_file(c_source)
	else:
		src = converter.parse_str(c_source)
	return src
