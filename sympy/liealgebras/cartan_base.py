from sympy.matrices.common import ShapeError
from sympy.matrices.matrices import MatrixBase
from sympy.core import Basic
from sympy.matrices import ImmutableMatrix, zeros, Matrix, eye
from sympy.core.sympify import _sympify
class Standard_Cartan(Basic):
    """
    Semi-Concrete base class for Cartan types such as A4, etc. In this module we make
    certain choices about how to represent the algebra.  This class is never meant to be
    called directly. It is exported as `CartanType` and should be called that way.

    Examples
    ========
    >>> from sympy.liealgebras import CartanType
    >>> CartanType("G2")
    TypeG('G', 2)

    Sources
    =======
    - https://inspirehep.net/literature/181168
    - https://www.researchgate.net/publication/252487471_Group_Theory_A_Physicist's_Survey
    - https://arxiv.org/pdf/1206.6379.pdf
    """

    def __new__(cls, series, n):
        n= _sympify(n)
        return super().__new__(cls, series, n)

    def __init__(self, *args, **kwargs):
        self._simple_roots=[Matrix(self.simple_root(i+1)) for i in range(self.rank)]
        self._is_default_basis=True

        # properties for caching
        self._omega_inv = None
        self._reflection_matrices_ = self.reflection_matrices()


    @property
    def rank(self):
        """
        Returns the rank of the Lie algebra
        """
        return self.args[1]

    @property
    def series(self):
        """
        Returns the type of the Lie algebra
        """
        return self.args[0]

    def cartan_matrix(self):
        r"""
        Returns the Cartan Matrix for the algebra. For a
        given simple Lie algebra the elements $a_{ij}$ can be
        generated by

        .. math::
            a_{ji} = 2 \langle\alpha_i, \alpha_j\rangle / \langle\alpha_j, \alpha_j\rangle

        where $a_i$ is the i'th simple root and $\langle,\rangle$ is the scalar product.

        Sources
        =======
        - https://en.wikipedia.org/wiki/Cartan_matrix
        - https://mathworld.wolfram.com/CartanMatrix.html

        """

        r = self.rank
        cartan_matrix = zeros(r,r)
        for i, sr_i in enumerate(self.simple_roots):
            for j, sr_j in enumerate(self.simple_roots):
                cartan_matrix[j,i] = 2 * sr_i.dot(sr_j) / sr_i.dot(sr_i)
        return cartan_matrix

    def cocartan_matrix(self):
        r"""
        Returns the Cocartan matrix. The Cocartan matrix
        row elements, $c_i$, are built from covectors of simple roots, $\alpha_i$.

        .. math::
            c_i = 2 \alpha_i / \langle \alpha_i, \alpha_i \rangle

        This relationship is helpful in defining the orthogonal base where
        multiplying by some weight, $w_j$, yields the unit matrix.

        .. math::
            \langle c_i, w_j \rangle = \delta_{ij}

        """
        return Matrix([
                2 * x / x.dot(x) for x in self.simple_roots])

    def omega_matrix(self):
        """
        Returns the omega matrix whose rows are built from
        the fundamental weights of the algebra in the orthogonal
        basis.
        """
        return self.cocartan_matrix().pinv().T

    def simple_root(self, i):
        """
        Returns the i'th simple root in the orthogonal basis.
        """
        raise NotImplementedError("Do not call this method directly from the base class.")

    @property
    def simple_roots(self) -> list:
        """
        Returns the simple roots of the algebra. This property
        accept overriding by passing your choice of roots. If this
        is done the entire algebra should recalculate its properties.

        Example
        =======
        >>> from sympy.liealgebras import CartanType
        >>> g2 = CartanType("G2")
        >>> sr = g2.simple_roots # defaulted
        >>> # g2.simple_roots = <my basis choice>
        """
        return self._simple_roots

    @simple_roots.setter
    def simple_roots(self, val):
        _list_of_mat_typecheck(val)
        self._simple_roots = val
        self._is_default_basis = False
        self._reflection_matrices_=self.reflection_matrices(val)
        self._omega_inv=self.omega_matrix().pinv()


    def fundamental_weight(self, i):
        r"""
        Returns the i'th fundamental weight of the algebra in the
        orthogonal basis.

        Note: To match consistency with simple roots, i starts at 1.

        Explanation
        ===========
        The weights of an algebra, lambda, can be
        written as a linear combination of the simple roots, $\alpha_i$.
        The following theorem,

        .. math::
            a_i = 2\langle\lambda, \alpha_i \rangle / \langle\alpha_i, \alpha_i \rangle


        where $a_i$ are the Dynkin labels.  The fundamental weights
        of the algebra are the weights, lambda, with the smallest $a_i >= 0$.
        Note that if $\lambda_i==\alpha_i$, then the Dynkin labels become
        the elements of the Cartan matrix.

        Sources
        =======
        - https://en.wikipedia.org/wiki/Weight_(representation_theory)
        - http://www.math.columbia.edu/~woit/notes11.pdf
        """
        i = i - 1
        return self.omega_matrix().row(i)

    def fundamental_weights(self):
        """
        Returns a list of the fundamental weights in the orthogonal basis
        """
        return [self.fundamental_weight(i) for i in range(self.omega_matrix().rows)]

    def rootsystem(self, **kwargs):
        """Returns the entire rootsystem of the algebra. This
        includes the positive, negative and zeros of the algebra.

        Examples
        ========
        >>> from sympy.liealgebras import CartanType
        >>> CartanType("A2").rootsystem()
        [Matrix([[1, 0, -1]]),
        Matrix([[0, 1, -1]]),
        Matrix([[1, -1, 0]]),
        Matrix([[0, 0, 0]]),
        Matrix([[0, 0, 0]]),
        Matrix([[-1, 1, 0]]),
        Matrix([[0, -1, 1]]),
        Matrix([[-1, 0, 1]])]
        """
        orbits = set()
        for i in self.simple_roots:
            for r in self.orbit(i):
                orbits.add(r)

        zero_roots = [self.simple_roots[0] * 0] * self.rank

        orbits = list(orbits) + zero_roots
        return sorted(orbits, key=self._orbit_sorter_lambda())


    def roots(self):
        """Returns the number of total roots in the algebra"""
        raise NotImplementedError("Do not call this method directly from the base class.")

    def root_level(self, root, basis='orthogonal'):
        """Returns the root level of the root. The root level is calculated
        by rotating by the omega matrix and then summing the rotated vector.
        The basis argument flags which basis the incoming root or weight is in.
        This class's default basis is 'orthogonal' but when this method is called
        in the rootsystem calculations, the weights are passed via the 'alpha'
        basis.

        Args:
            root (Matrix): A Matrix of shape (1, rank)
            basis (str): Which basis incoming root or weight is in.

        Examples
        ========
        >>> from sympy.liealgebras import CartanType
        >>> g2 = CartanType("G2")
        >>> rs = g2.rootsystem()
        >>> g2.root_level(rs[0])
        5
        """
        if basis == "orthogonal":
            return sum(root * self.omega_matrix().pinv() * self.cartan_matrix().pinv())
        else:
            return sum(root * self.cartan_matrix().pinv())

    def _orbit_sorter_lambda(self, basis="orthogonal"):
        """Returns a function that takes in a weight and generates the
        the tuple for sorting rootsystem, positiveroots, orbits. Constructing
        the function return type allows caching for
        """
        self._omega_inv = self._omega_inv or self.omega_matrix().pinv()
        inverse_cartan = self.cartan_matrix().pinv()
        rot = inverse_cartan
        if basis == "orthogonal":
            rot = self._omega_inv * rot

        def sorter(w):
            a = w * rot
            return (-sum(a), tuple(a))
        return sorter

    def is_dom(self, w, backend="orthogonal"):
        """Returns a boolean on whether the weight or root passed
        is dominant under the algebra. A dominant weight is a
        weight where all the dynkin coefficients are positive. The
        default basis in this class is orthogonal, but to get the basis
        where each element in the vector is a dynkin coefficient, it
        needs to be rotated to the omega basis by multiplying it by
        omega inverse.
        """
        if backend == "orthogonal":
            self._omega_inv = self._omega_inv or self.omega_matrix().pinv()
            w = w * self._omega_inv
        return all([i >= 0 for i in w.row(0)])

    def _reflect_with_mats(self, weights, matrices):
        """Utility method for rotating list of weights by
        list of matrices and returning the unique results"""
        results = set(weights)
        for w in weights:
            results = results.union([w * r for r in matrices])
        return list(results)

    def rotate_to_dominant(self, weight):
        """Returns the domiant weight by
        continually rotates the weight and its reflections
        until the dominant weight is found.
        Weight is in the orthogonal basis."""
        if self.is_dom(weight):
            return weight

        running_list = set([weight])
        while True:
            temp_list = set()
            for i in running_list:
                # rather than call _reflect_with_mats
                # we choose to check each reflection
                # so when running_list gets big, we
                # aren't wasting compute if the dom
                # is halfway through this iteration's
                # list
                for r in self._reflection_matrices_:
                    rotated = i * r
                    if self.is_dom(rotated):
                        return rotated
                    temp_list.add(rotated)
            running_list = running_list.union(temp_list)

    def _full_orbit(self, weight, stabs):
        """Construct the full orbit from reflecting repeatedly
        until all the roots are accounted for."""
        orbit = [weight]
        for _ in range(self.roots() // 2):
            orbit = self._reflect_with_mats(orbit, stabs)
        return orbit

    def positive_roots(self):
        """Returns the set of all positive roots that are greater
        than zero in weight from the rootsystem.
        """
        n_pos = self.roots() // 2
        return self.rootsystem()[:n_pos]

    def orbit(self, weight, stabilizer=None, **kwargs):
        """
        Returns the orbit of the weight or root by reflecting it
        a plane. A stabilizer may be passed to calculate the orbit using
        the Orbit-Stabilizer theorem.

        Note the stabilizer starts counting simple roots at index 0

        Args:
            weight (Matrix): A Matrix of shape (1, rank)
            stabilizer (Iterable of ints, optional): Per Orbit-Stabilizer
            theorem, integer iterable of simple root indexes. Defaults to None.

        Sources
        =======
        - https://en.wikipedia.org/wiki/Coadjoint_representation#Coadjoint_orbit
        - https://en.wikipedia.org/wiki/Group_action#Orbits_and_stabilizers

        """
        if stabilizer is None:
            stab_refl_mats = self._reflection_matrices_
        else:
            stab_refl_mats = [self._reflection_matrices_[i] for i in stabilizer]

        if not isinstance(weight, ImmutableMatrix):
            weight = weight.as_immutable()

        dominant_weight = self.rotate_to_dominant(weight)

        full_orbit = self._full_orbit(dominant_weight, stab_refl_mats)

        return sorted(full_orbit, key=self._orbit_sorter_lambda())


    def reflection_matrices(self, weight=None):
        """Returns reflection matricies depending on how
        weight is (or isn't) passed.

        - If weight is None, then
        a set of reflection matrices generated from simple roots are
        returned.
        - If weight is type of Matrix then a single matrix
        is returned by rotating the weight.
        - If weight is type of list (implied of MatrixBase) then
        rotations are done on each MatrixBase and returned.
        """

        # simple_roots generated reflection matrices
        if weight is None:
            return [reflection_matrix(x) for x in self.simple_roots]

        if isinstance(weight, MatrixBase):
            return reflection_matrix(weight)

        if isinstance(weight,list):
            return [reflection_matrix(x) for x in weight]


def reflection_matrix(v):
    """Returns the reflection matrix to reflect about a vector
    """
    return (eye(len(v)) - 2 * v.T * v / v.dot(v)).as_immutable()


def _list_of_mat_typecheck(val):
    """Runs validation on a list of matrices"""
    if isinstance(val, list):
        for obj in val:
            if not isinstance(obj, Matrix):
                raise TypeError("Simple roots must be list of sympy.Matrix")
            if obj.shape[-1] == 1:
                raise ShapeError("Simple roots must be of shape (1,-1)")
