"""Prime ideals in number fieldds. """

from sympy import symbols
from sympy.core.power import binpow
from sympy.polys import Poly
from sympy.polys.domains import GF, ZZ
from sympy.polys.numberfields.basis import round_two, nilradical_mod_p
from sympy.polys.numberfields.forms import HNF, StandardRep
from sympy.polys.numberfields.modules import (
    HnfEndomorphismRing, ModuleEndomorphism)
from sympy.polys.numberfields.utilities import coeff_search, is_int
from sympy.utilities import public, filldedent


class PrimeIdeal:
    """
    A prime ideal in a ring of algebraic integers.
    """

    def __init__(self, p, alpha, e, f, ZK):
        """
        Parameters
        ----------
        p: the rational prime this ideal divides
        alpha: a generator as StandardRep, such that the ideal is p*ZK + alpha*ZK
        e: the ramification index
        f: the inertia degree
        ZK: an HNF giving an integral basis for the ring of integers
          where this ideal lives
        """
        self.p = p
        self.alpha = alpha
        self.e = e
        self.f = f
        self.ZK = ZK
        self._beta = None

    def pretty(self, theta=None):
        theta = theta or symbols('x')
        p, alpha, e, f = self.p, self.alpha, self.e, self.f
        alpha_rep = str(alpha.numerator(x=theta).as_expr())
        if alpha.denom > 1:
            alpha_rep = f'({alpha_rep})/{alpha.denom}'
        return f'[ ({p}, {alpha_rep}) e={e}, f={f} ]'

    def __repr__(self):
        return self.pretty()

    def to_HNF(self):
        return self.p * self.ZK + self.alpha * self.ZK

    def clone(self):
        return PrimeIdeal(self.p, self.alpha, self.e, self.f, self.ZK)

    def __eq__(self, other):
        return self.to_HNF() == other

    def __mul__(self, other):
        return self.to_HNF() * other

    def __rmul__(self, other):
        return self * other

    def __pow__(self, a):
        if is_int(a):
            if a < 0:
                return NotImplemented
            elif a == 0:
                return self.ZK * 1  # "times 1" achieves clone
            elif a == 1:
                return self.clone()
            else:
                return binpow(self, a)
        return NotImplemented

    @property
    def beta(self):
        """
        Write P for this prime ideal, p for the rational prime it divides.
        Then, for computing P-adic valuations it is useful to have a number
        beta in ZK such that p/P = p*ZK + beta*ZK. This is the "reagent"
        from Kummer's 1847 paper.
        """
        if self._beta is None:
            self._beta = _compute_beta(self.p, [self.alpha], self.ZK)
        return self._beta

    def valuation(self, I):
        """
        Compute the P-adic valuation of integral ideal I, given as an HNF.
        """
        return prime_valuation(I, self)


def _compute_beta(p, gens, ZK):
    """
    Compute the "beta" for a PrimeIdeal P (see `beta` property in that class).

    Parameters
    ----------
    p: the rational prime P divides
    gens: list of StandardReps being generators for P. Rational p may safely
      be omitted, since we will skip it anyway.
    ZK: integral basis

    Returns
    -------
    StandardRep for beta
    """
    from sympy.matrices import Matrix
    B = Matrix()
    E = HnfEndomorphismRing(ZK)
    for g in gens:
        if g == p:
            continue
        phi = E.inner_endomorphism(g)
        B = B.col_join(phi.matrix(modulus=p))
    B = B.to_domain(GF(p))
    # A nonzero element of the nullspace of B will represent a
    # lin comb over the omegas which (i) is not a multiple of p
    # (since it is nonzero over GF(p)), while (ii) is such that
    # its product with each g in gens _is_ a multiple of p (since
    # B represents multiplication by these generators). Theory
    # predicts that such an element must exist, so nullspace should
    # be non-trivial.
    x = B.nullspace().to_Matrix().row(0).T
    beta = StandardRep.from_matrix_col(ZK.T, ZK.W * x, 0, ZK.d)
    return beta


@public
def prime_valuation(I, P):
    """
    Compute the p-adic valuation for an ideal I at a given prime ideal.

    Parameters
    ----------
    I: HNF giving an integral ideal whose valuation is desired.
    P: specification of the prime ideal. Can be of one of two forms:
       - a PrimeIdeal instance, or
       - a triple (p, gens, ZK), where:
            p: the rational prime.
            gens: list of StandardReps giving Z_K-generators of a prime ideal
              lying over p.
            ZK: HNF giving an integral basis for the field K.

    Returns
    -------
    int (non-negative since I is required to be an integral ideal) giving the
    p-adic valuation of I at the prime above p generated by gens.

    Examples
    --------
    ... TODO

    References
    ==========

    [1] Cohen, H. A Course in Computational Algebraic Number Theory.

    """
    if isinstance(P, PrimeIdeal):
        p, ZK = P.p, P.ZK
    else:
        p, gens, ZK = P

    T, n, W, d = ZK.T, ZK.n, ZK.W, ZK.d

    A = W.inv() * I.W * d / I.d
    D = A.det()
    if D % p != 0:
        return 0

    beta = P.beta if isinstance(P, PrimeIdeal) else _compute_beta(p, gens, ZK)

    f = d ** n // W.det()
    need_complete_test = (f % p == 0)
    v = 0
    while True:
        # Entering the loop, the cols of A represent lin combs of omegas.
        # Turn them into lin combs of thetas:
        A = W * A
        # And then one column at a time...
        for j in range(n):
            c = StandardRep.from_matrix_col(T, A, j, d)
            c *= beta
            # ...turn back into lin combs of omegas, after multiplying by beta:
            c = ZK.represent(c, domain=ZZ)
            for i in range(n):
                A[i, j] = c[i]
        if A[n - 1, n - 1] % p != 0:
            break
        A = A / p
        if need_complete_test:
            if any(not is_int(A[k]) for k in range(n**2)):
                break
        v += 1
    return v


def _two_elt_rep(gens, T, p, f=None, Np=None, ZK=None):
    """
    Given a set of Z_K-generators of a prime ideal, compute a set of just two
    Z_K-generators for the same ideal, one of which is p itself.

    Parameters
    ----------
    gens: list of StandardRep instances giving generators for the prime ideal,
       over Z_K, the ring of integers of K.
    T: monic minimal polynomial over ZZ defining the field K.
    p: the rational prime divided by the prime ideal.
    f: (optional): the inertia degree of the prime ideal, if known.
    Np: (optional): the norm == p**f of the prime ideal, if known.
      NOTE: There is no reason to supply both `f` and `Np`. Either one will
      save us from having to compute the norm `Np` ourselves. If both are known,
      `Np` is preferred since it saves one exponentiation.
    ZK: (optional): if known, an HNF giving an integral basis for K, of special
      form, where first element must be 1.

    Returns
    -------
    StandardRep for algebraic integer alpha such that the prime ideal is
    equal to p*ZK + alpha*ZK.
    """
    # Detect the special case where all generators are multiples of p:
    if all(g % p == 0 for g in gens):
        return StandardRep.zero(T)

    if Np is None:
        if f is not None:
            Np = p**f
        else:
            Np = abs(HNF.from_std_reps(gens).det())

    if ZK is None:
        ZK, dK = round_two(T)

    omega = ZK.standard_reps()
    if omega[0] != 1:
        raise ValueError(filldedent('''
            To compute two-element prime rep, first element of integral basis
            must be equal to unity.
        '''))
    beta = [p*om for om in omega[1:]]  # note: we omit omega[0] == 1
    beta += gens
    search = coeff_search(len(beta), 1)
    for c in search:
        alpha = sum(ci*betai for ci, betai in zip(c, beta))
        # Note: It may be tempting to reduce alpha mod p here, to try to work
        # with smaller numbers, but must not do that, as it can result in an
        # infinite loop! E.g. try factoring 2 in Q(sqrt(-7)).
        n = alpha.norm(T) // Np
        if n % p != 0:
            # Now can reduce alpha mod p.
            return alpha % p


def _prime_decomp_easy_case(p, ZK):
    """
    Compute the decomposition of rational prime p in the ring of integer ZK
    (given as HNF), in the "easy case", i.e. the case where p does not divide
    the index of theta in ZK, theta a root of ZK.T.
    """
    T = ZK.T
    T_bar = Poly(T, modulus=p)
    lc, fl = T_bar.factor_list()
    return [PrimeIdeal(p, StandardRep.from_poly(T, Poly(t, domain=ZZ)),
                         e, t.degree(), ZK)
            for t, e in fl]


def _prime_decomp_compute_kernel(I, p, ZK):
    """
    Parameters
    ----------
    I: a Module, representing an ideal of ZK/pZK.
    p: the rational prime being factored
    ZK: the integral basis HNF

    Returns
    -------
    Pair (N, G), where:
      N: Module representing the kernel of the map a |--> a**p - a on (O/pO)/I,
         guaranteed to be a module with unity, along with
      G: Module representing a basis for the separable algebra A = O/I (see Cohen).
    """
    from sympy.matrices.subspaces import supplementary_space
    W = I.matrix
    n, r = W.shape
    # Want to take the Fp-basis given by the columns of I, adjoin (1, 0, ..., 0)
    # (which we know is not already in there since I is a basis for a prime ideal)
    # and then supplement this with additional columns to make an invertible n x n
    # matrix. This will then represent a full basis for ZK, whose first r columns
    # are pullbacks of the basis for I.
    if r == 0:
        B = W.eye(n)
    else:
        B = W.row_join(W.eye(n).col(0))
    if B.cols < n:
        B = supplementary_space(B, domain=GF(p))
    G = ZK.submodule(B).discard_before(r)
    phi = ModuleEndomorphism(G, lambda x: x**p - x, modulus=p)
    N = phi.kernel()
    assert N.with_unity()
    return N, G


def _prime_decomp_maximal_ideal(I, p, ZK):
    """
    We have reached the case where we have a maximal (hence prime) ideal I,
    which we know because the quotient O/I is a field.

    Parameters
    ----------
    I: a Module representing an ideal of O/pO.
    p: the rational prime being factored
    ZK: the integral basis

    Returns
    -------
    PrimeIdeal instance representing this prime
    """
    f = I.m - I.n
    G = ZK.matrix * I.matrix
    gens = [StandardRep.from_matrix_col(ZK.T, G, j, ZK.d) for j in range(G.cols)]
    alpha = _two_elt_rep(gens, ZK.T, p, f=f, ZK=ZK)
    e = prime_valuation(p * ZK, (p, [alpha], ZK))
    return PrimeIdeal(p, alpha, e, f, ZK)


def _prime_decomp_split_ideal(I, p, N, G, ZK):
    from sympy.matrices import Matrix
    from sympy.matrices.common import NonInvertibleMatrixError
    assert I.container is ZK and G.container is ZK and N.container is G
    alpha = N.recast_in_container(N(1))
    assert alpha.module is G
    s = G.n
    powers_elts = [1, alpha]
    powers_matrix = N.matrix[:, :2]
    # By choice of alpha, we know its minimal poly is deg at least 2, so we
    # can start by examining alpha^2.
    ak = alpha * alpha
    for k in range(2, s+1):
        ak_col = ak.column()
        try:
            D = powers_matrix.to_domain(GF(p))
            c = ak_col.to_domain(GF(p))
            x = D.lu_solve(c)
        except NonInvertibleMatrixError:
            # This means alpha^k still isn't in the Fp-span of the lower powers.
            powers_matrix = powers_matrix.row_join(ak_col)
            powers_elts.append(ak)
            ak *= alpha
        else:
            # alpha^k is in the Fp-span of the lower powers, so we have found a
            # minimal degree poly for alpha.
            coeffs = [1] + [-c for c in reversed(x.to_list_flat())]
            from sympy.abc import X
            m = Poly(coeffs, X, modulus=p)
            break
    else:
        # This case should never arise.
        # A is an s-dimensional space over Fp, and alpha is an element of A.
        # If we reach this point, then we have represented each of the first s+1
        # powers of alpha (1, alpha, ..., alpha^s) over our basis for A, and
        # this set of s+1 vectors is showing as linearly independent. Something
        # is wrong.
        assert False

    # TODO: we don't actually need full factorization, so might use a faster method
    #  to just break off a single non-constant factor m1?
    lc, fl = m.factor_list()
    m1 = fl[0][0]
    m2 = m.quo(m1)
    # TODO: Cohen suggests you don't actually need U and V? Does that work?
    U, V, g = m1.gcdex(m2)
    # Sanity check: theory says m is squarefree, so m1, m2 should be coprime:
    assert g == 1
    E = list(reversed((U*m1).all_coeffs()))
    eps1 = sum(E[i]*powers_elts[i] for i in range(len(E)))
    eps2 = 1 - eps1
    eps = [eps1, eps2]
    n = ZK.n
    d = I.n
    HH = []
    for k in range(2):
        e = G.recast_in_container(eps[k])
        assert e.module is ZK
        M = Matrix()
        M = M.row_join(I.matrix)
        for om in ZK.basis_elements():
            M = M.row_join((e*om).column())
        D = M.to_domain(GF(p))
        W = D.columnspace().to_Matrix()
        H = ZK.submodule(W)
        HH.append(H)
    return HH


@public
def prime_decomp(p, T=None, dK=None, ZK=None, radical=None):
    """
    Compute the decomposition of rational prime p in the field K defined by the
    monic, minimal polynomial T.

    Ordinarily this should be accessed through an py:class:`AlgebraicField`.

    Parameters
    ----------
    p: the rational prime whose decomposition is desired.
    T: minimal, monic polynomial defining the number field K in which to factor.
    dK: (optional) the discriminant of the field K, if already known.
    ZK: (optional) an integral basis for K in Hermite Normal Form, if already known.
    radical: (optional) a GF(p)-basis for the nilradical mod p in the integers of K,
      if already known.

    Returns
    -------
    List of :ref:`PrimeIdeal` instances.

    Examples
    --------
    >>> from sympy import Poly, QQ
    >>> from sympy.abc import x, theta
    >>> T = Poly(x ** 3 + x ** 2 - 2 * x + 8)
    >>> K = QQ.algebraic_field((T, theta))
    >>> K.primes_above(2)
    [[ (2, x**2 + 1) e=1, f=1 ], [ (2, (x**2 + 3*x + 2)/2) e=1, f=1 ], [ (2, (3*x**2 + 3*x)/2) e=1, f=1 ]]

    References
    ==========

    [1] Cohen, H. A Course in Computational Algebraic Number Theory.

    """
    radicals = {}
    if T is None and ZK is None:
        raise ValueError('At least one of T or ZK must be provided.')
    if T is None:
        T = ZK.T
    if dK is None or ZK is None:
        ZK, dK = round_two(T, radicals=radicals)
    dT = T.discriminant()
    f_squared = dT // dK
    if f_squared % p != 0:
        return _prime_decomp_easy_case(p, ZK)
    radical = radical or radicals.get(p) or nilradical_mod_p(ZK, p)
    stack = [radical]
    primes = []
    while stack:
        I = stack.pop()
        N, G = _prime_decomp_compute_kernel(I, p, ZK)
        if N.n == 1:
            P = _prime_decomp_maximal_ideal(I, p, ZK)
            primes.append(P)
        else:
            I1, I2 = _prime_decomp_split_ideal(I, p, N, G, ZK)
            stack.extend([I1, I2])
    return primes
