diff --git a/sympy/sets/sets.py b/sympy/sets/sets.py
index d570208..99340ef 100644
--- a/sympy/sets/sets.py
+++ b/sympy/sets/sets.py
@@ -1350,7 +1350,6 @@ def roundrobin(*iterables):
     def is_real(self):
         return all(set.is_real for set in self.args)
 
-
 class Intersection(Set):
     """
     Represents an intersection of sets as a :class:`Set`.
@@ -1462,6 +1461,43 @@ def _handle_finite_sets(args):
             return
         s = fs_args[0]
         fs_args = fs_args[1:]
+	if len(s) == 1 and len(new_args) == 1 and isinstance(new_args[0], Interval):
+	    ineq = s.__iter__().next()
+            q = ineq.primitive()[0]
+            ineq = ineq / q
+            st = Mul(new_args[0].start) / Mul(q)
+            en = Mul(new_args[0].end) / Mul(q)
+            q = ineq.as_coeff_Add()[0]
+            ineq -= q
+	    st -= q
+	    en -= q
+            q = ineq.primitive()[0]
+	    ineq /= Mul(q)
+	    st /= Mul(q)
+	    en /= Mul(q)
+            q = ineq.free_symbols.__iter__()
+	    tmp = []
+            while True:
+                try:
+                    tmp.append((q.next(), 1))
+	        except StopIteration:
+		    break
+            tmp1 = []
+            for i in ineq.args:
+                if(i.subs(tmp) < 0):
+                    tmp1.append(i * -1)
+                else:
+                    tmp1.append(i)
+            tmp2 = [i for i in (-1 * ineq).args]
+	    if set(tmp1) == set(tmp2) or (len(tmp2) == 0 and ineq.subs(tmp) < 0):
+                st *= -1
+                en *= -1
+                ineq *= -1
+            if st > en:
+                st, en = en, st
+            if(len(tmp) > 0):
+                other_sets = Interval(Mul(st), Mul(en))
+                return Intersection(FiniteSet(ineq), other_sets, evaluate = False)
         res = []
         unk = []
         for x in s:
diff --git a/sympy/sets/tests/test_sets.py b/sympy/sets/tests/test_sets.py
index ec7538c..e573a90 100644
--- a/sympy/sets/tests/test_sets.py
+++ b/sympy/sets/tests/test_sets.py
@@ -948,3 +948,21 @@ def test_issue_9447():
             S.UniversalSet, Union(Interval(0, 1), Interval(2, 3)), evaluate=False)
     assert Complement(S.Naturals, a) == Complement(
             S.Naturals, Union(Interval(0, 1), Interval(2, 3)), evaluate=False)
+
+def test_issue_10285():
+    from sympy import Mul
+    x = Symbol('x')
+    y = Symbol('y')
+    assert FiniteSet(2*x + 1).intersect(Interval(3, 5)) == FiniteSet(x).intersect(Interval(1, 2))
+    assert FiniteSet(x*y + 1).intersect(Interval(3, 5)) == FiniteSet(x*y).intersect(Interval(2, 4))
+    assert FiniteSet(2*x + 2*y).intersect(Interval(2, 4)) == FiniteSet(x + y).intersect(Interval(1, 2))
+    assert FiniteSet(2*x + 1).intersect(Interval(2, 4)) == FiniteSet(x).intersect(Interval(Mul(1) / 2, Mul(3) / 2))
+    assert FiniteSet((2*x + 1) / 3).intersect(Interval(2, 4)) == FiniteSet(x).intersect(Interval(Mul(5) /2, Mul(11) /2))
+    assert FiniteSet(x).intersect(Interval(2, 3)) == FiniteSet(x).intersect(Interval(2, 3))
+    assert FiniteSet(2*x/3 + 3*y/2).intersect(Interval(2, 4)) == FiniteSet(4*x + 9*y).intersect(Interval(12, 24))
+    assert FiniteSet(-2*x - 1).intersect(Interval(3, 5)) == FiniteSet(x).intersect(Interval(-3, -2))
+    assert FiniteSet(-2*x/3 - 3*y/2).intersect(Interval(2, 4)) == FiniteSet(4*x + 9*y).intersect(Interval(-24, -12))
+    assert FiniteSet(-2*x - 2*y + 1).intersect(Interval(3, 5)) == FiniteSet(x + y).intersect(Interval(-2, -1))
+    assert FiniteSet(-2*x - 2*y - 1).intersect(Interval(3, 5)) == FiniteSet(x + y).intersect(Interval(-3, -2))
+    assert FiniteSet(-2*x + 2*y - 1).intersect(Interval(3, 5)) == FiniteSet(-x + y).intersect(Interval(2, 3))
+
